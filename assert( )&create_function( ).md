# ✅ 문자열을 코드로 해석·실행할 수 있는 함수 (RCE)

`eval`, `assert`, `create_function` 같은 런타임 코드 생성/실행 함수들은 **문자열을 코드로 해석·실행할 수 있기 때문에** 매우 위험합니다. 외부 입력이 일절 검증 없이 이들 함수로 들어가면 **원격 코드 실행(RCE)** 등 심각한 보안 사고로 이어질 수 있습니다. ⚠️

---

# 🔎 함수별 핵심 포인트

## `assert()`

* 역할: 표현식을 검사하여 `false`면 에러/예외를 발생시킴.
* 위험 포인트: **문자열 인자를 받으면 그 문자열을 PHP 코드로 평가**할 수 있음(버전·설정에 따라 다름).
* 보안 요약: 외부 입력을 `assert()`에 직접 넣지 말 것. 🛑

## `create_function()`

* 역할: 런타임에 문자열로 함수 바디를 받아 익명함수 생성(내부적으로 `eval` 유사).
* 위험 포인트: 인자에 외부 입력이 섞이면 즉시 임의 코드 실행 가능.
* 상태: PHP 7.2에서 deprecated, PHP 8.0에서 제거됨(레거시 코드 주의). ⚠️

---

# 🔥 왜 위험한가? 

* **외부 입력 → 문자열 코드화 → 런타임 실행** 흐름이 핵심 위험 경로.
* 문자열이 검증 없이 실행되면 공격자가 서버에서 임의 명령·파일 접근·정보유출 등을 수행할 수 있음. 💥

---

# 🧭 공격 시나리오 (개념적·방어 목적)

1. **직접 입력 → 코드 실행 (RCE)**

   * 예: `eval($_GET['expr']);` — `expr`에 악성 코드 삽입 → 즉시 실행
2. **파일 업로드 + 실행**

   * 업로드된 텍스트를 `eval()`로 처리하면 업로드 파일의 코드가 실행됨
3. **로그 포이즈닝 → 포함 → 실행**

   * User‑Agent 등에 PHP 코드를 남겨두고, LFI로 그 로그를 `include()`하면 실행 가능
4. **동적 함수 생성 (create_function)**

   * 사용자 입력으로 함수 바디를 만들면 내부적으로 eval과 동일한 문제 발생
5. **assert() 오용**

   * 환경에 따라 문자열이 평가되어 eval처럼 동작할 수 있음

> 요약: 외부 데이터가 코드로 해석되는 모든 흐름이 문제. 🚨

---

# 🕵️ 탐지 · 헌팅 (방어용 명령어)

* 정적 스캔(코드베이스):

```bash
grep -R --line-number -E "(\beval\s*\(|\bcreate_function\s*\(|\bassert\s*\()" .
```

* 요청·로그 모니터링: `<?php`, `php://input`, 긴 base64, 코드 조각 포함 여부 탐지

---

# 🧾 운영·설정 

* `zend.assertions`, `assert.exception` 등 assertion 관련 설정 점검 → 프로덕션에서 assertions 안전하게 관리
* 필요 시 시스템 함수(`exec`, `system`, `shell_exec`, `popen`, `proc_open`) `disable_functions` 고려(영향 분석 필요)
* 파일 권한 최소화: 웹 프로세스가 민감 파일을 쓰거나 실행하지 못하도록 제한

