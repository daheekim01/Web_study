`eval`, `assert`, `create_function` 같은 **런타임 코드 생성/실행 함수들을 금지해야 하는 이유**와, **공격자가 어떻게(개념적으로)** 악용할 수 있는지, 그리고 **안전한 대체 코드·탐지·완화 방법**을 한 번에 정리할게. 🛡️✨

// 매우 위험: 유저 입력을 그대로 파일명/코드로 사용
include($_GET['page']);
eval($_POST['code']);




* **`assert()`**: 표현식(혹은 일부 환경에서 문자열)을 평가해서 실패 시 동작을 트리거하는 함수. **문자열이 코드로 평가될 수 있어** 사용자 입력이 들어가면 RCE로 이어질 수 있음.
* **`create_function()`**: 런타임에 문자열을 받아 PHP 함수(Closure)를 생성하는 오래된 함수. 내부적으로 `eval`과 유사하게 작동하므로 **즉시 위험** — 현재는 **사용 중단(deprecated)** 되었고 최신 PHP에서는 제거됨.

둘 다 **외부 입력을 그대로 코드로 실행할 가능성** 때문에 보안상 매우 민감하다. ✅

---

## 1) `assert()` — 자세한 설명과 보안 이슈

### 기능(개념)

* `assert()`는 주로 디버깅·검증 목적으로 사용된다. 인자(보통 boolean 표현식)를 검사해서 `false`면 경고/예외를 발생시킨다.
* 하지만 **인자로 문자열이 들어가면 그 문자열을 PHP 코드로 평가(evaluate)** 하는 동작을 하는 환경/버전/설정이 존재한다 — 이 부분이 위험의 핵심이다.

### 버전·설정 관련 중요 포인트 (검토 필요)

* PHP 버전 및 `php.ini`의 assertion 관련 설정(`zend.assertions`, `assert.exception` 등)에 따라 `assert()`의 동작(컴파일 단에서 제거될지, 문자열 평가를 허용할지, 실패 시 예외를 던질지 등)이 달라진다.
* **결론**: 운영 환경의 PHP 문서/설정을 반드시 확인해야 한다. (서버에서 `phpinfo()` 또는 `php -i`로 확인)

### 보안 위험

* 만약 코드가 `assert($_GET['x']);` 같은 식으로 사용자 입력을 넘겨받고, 해당 PHP 환경에서 문자열을 평가한다면 공격자가 임의 PHP 코드를 주입해 **원격코드실행(RCE)** 을 달성할 수 있다.
* `assert()` 자체가 예외/에러를 발생시키는 지점에 hooks(예: 사용자 정의 에러 핸들러)가 있으면 추가 권한 상승·정보 유출 경로가 생길 수 있다.

### 방어 권장

* **절대** 사용자 입력을 `assert()`에 직접 넣지 마라.
* 프로덕션에서는 assertions를 비활성화하거나(환경에 따라) 컴파일 단계에서 제거하도록 설정하라.
* 단위테스트/디버깅용일 뿐이며, 런타임 로직 결정에 의존하면 안 된다.

---

## 2) `create_function()` — 자세한 설명과 보안 이슈

### 기능(개념)

* `create_function('$args', 'body')`는 런타임에 문자열로 전달된 `body`를 바탕으로 익명 함수를 생성한다. 내부적으로 문자열을 코드로 컴파일/평가(즉 `eval`)한다.
* 매우 편리하지만 위험하고 비효율적이라 **PHP 7.2에서 deprecate(사용 중단 경고)** 되었고 **PHP 8.0에서 제거**되었다.

### 보안 위험

* `create_function()`의 인자(특히 함수 바디)가 외부 입력과 직접 결합되거나 조작될 수 있으면 **임의 코드 실행(RCE)** 이 가능하다.
* 문자열로 코드를 만들기 때문에 정적 분석을 우회하고, 전달된 입력을 통해 시스템 명령이나 파일 시스템 접근 등을 실행할 수 있다.

### 왜 지금도 언급되나?

* 오래된 코드베이스(레거시 PHP 앱, 오래된 플러그인/테마)에 아직 남아 있는 경우가 많아서 공격자가 이를 노릴 수 있다.
* 제거된 함수지만 **코드베이스 스캔**에서 발견되면 즉시 리팩토링이 필요하다.

### 안전한 대체

* PHP의 네이티브 익명함수(Closure)를 사용하라:

```php
// 나쁜 예 (deprecated / 위험)
$fn = create_function('$x', 'return intval($x) * 2;');

// 안전한 대체 (closure)
$fn = function($x) { return intval($x) * 2; };
```

* 동적으로 코드를 생성해야 하는 설계 자체를 재검토하고, 가능한 경우 **전략 패턴(미리 정의된 콜백 맵)** 으로 대체하라.

---

## 3) 구체적 위험 시나리오(개념적 — 방어 목적)

* `assert($_GET['a']);` — 만약 문자열 입력이 eval처럼 처리된다면 `$_GET['a']="phpinfo();"` 등으로 시스템 정보 노출 가능.
* `create_function('$x', $_POST['body']);` — 업로드된 템플릿/스크립트를 통해 서버에서 임의 동작 수행.
* 요약: **외부 입력 → 문자열 코드화 → 런타임 실행** 이 핵심 위험 경로다.

(참고: 실제 페이로드·공격 절차는 제공하지 않습니다 — 방어 목적 설명만)

---

## 4) 실전 방어 가이드 (우선순위 높은 것부터)

### A. 코드 레벨 (개발자용)

1. **절대** 사용자 입력을 `eval`, `assert`(문자열), `create_function`의 인자로 넘기지 마라.
2. **대체패턴** 사용:

   * 화이트리스트 + 맵핑:

     ```php
     $actions = [
       'list' => 'list_items',
       'status' => 'get_status'
     ];
     $k = $_GET['act'] ?? '';
     if (!isset($actions[$k])) { http_response_code(400); exit; }
     call_user_func($actions[$k]);
     ```
   * 클로저(Closure) 사용:

     ```php
     $handlers = [
       'ping' => function(){ return 'pong'; },
     ];
     $handlers[$k]();
     ```
3. **파서 사용**: 문자열 표현식을 안전하게 해석해야 한다면, 신뢰할 수 있는 파서/라이브러리(수식 파서·템플릿 엔진 등)를 사용하라.

### B. 운영/설정 레벨

1. **PHP 설정 점검**: `zend.assertions`, `assert.exception` 등 관련 설정을 확인하고, 프로덕션에서는 assertions를 비활성화하거나 안전하게 설정하라. (환경 문서 확인 필수)
2. **`disable_functions` 검토**: `eval` 자체는 함수가 아니라서 disable 불가하지만, `exec`, `system`, `shell_exec`, `popen`, `proc_open` 등 시스템 명령 관련 함수는 필요에 따라 비활성화 고려.
3. **권한 최소화**: 웹 프로세스 권한으로 민감 파일을 쓰거나 실행할 수 없게 제한.

### C. 탐지·헌팅

* 정적 스캔(코드베이스):

  ```bash
  # 방어용 grep 예시
  grep -R --line-number -E "(\beval\s*\(|\bcreate_function\s*\(|\bassert\s*\()" .
  ```
* WAF/로그 규칙: 요청 바디/헤더에 `<?php` 또는 긴 base64/코드 패턴이 포함되면 경보.
* 파일 무결성(FIM): 웹루트의 .php 파일 변경 감지.



 


# 공격 시나리오(개념적·비전술적) 🔍

> 아래는 “어떻게 위험해지는가”를 이해하기 위한 **개념적 예시**야. 실제 공격 페이로드나 단계는 제공하지 않을게 — 방어를 위한 맥락을 주는 목적이야.

1. **직접적인 입력 → 코드 실행 (RCE)**

   * 취약 코드: `eval($_GET['expr']);`
   * 공격자: `expr`에 악의적 PHP 코드를 넣음 → 서버가 그 코드를 실행 → 쉘 실행·데이터 유출·권한 상승 가능.

2. **파일 업로드 + 실행**

   * 웹앱이 업로드된 텍스트를 읽어 `eval()`로 처리하면 업로드된 파일에 담긴 PHP로 서버가 동작하게 됨.

3. **로그 포이즈닝 → 포함 → 실행**

   * 공격자가 로그(User-Agent 등)에 PHP 코드를 남김 → LFI로 로그 파일을 포함(include)하면서 `eval()`이 실행되면 코드가 돌아감.

4. **입력값을 조합한 동적 함수 생성 (create_function)**

   * `create_function`은 내부적으로 `eval`과 유사. 사용자 입력으로 함수 바디를 만들면 같은 문제가 발생.

5. **assert()의 오용**

   * `assert($user_input)`는 PHP 설정에 따라 표현식을 평가하거나, 문자열이면 `eval`처럼 동작할 수 있음(특히 PHP 5 계열에서 위험). 최신 PHP(예: 7+)도 사용법에 따라 위험할 수 있음.

> 요약: 외부 제어 데이터를 그대로 코드로 해석하면 공격자는 임의 동작을 시킬 수 있다.

---

# 안전한 대체 방법 (구현 예제 포함) ✅

## 1) `eval()` 대신 **화이트리스트 + 매핑**

사용자 요청을 그대로 실행하는 대신, 가능한 동작을 미리 정의한 함수/핸들러로 매핑한다.

### 취약(나쁜) 예 — *절대 사용 금지*

```php
// 위험: 외부 입력을 그대로 eval()
eval($_GET['action']); 
```

### 안전(권장) 예

```php
// 안전: 허용된 액션만 처리
$allowed = [
  'list' => function() { return list_items(); },
  'status' => function() { return server_status(); },
];

$action = $_GET['action'] ?? '';
if (isset($allowed[$action])) {
    echo $allowed[$action]();
} else {
    http_response_code(400);
    echo "Invalid action";
}
```

## 2) `assert()` 대신 **명확한 검증/파서 사용**

* 수식 평가가 필요하면 안전한 수식 파서(수학 전용 파서 등)를 사용.
* 표현식 언어가 필요하면 검증 가능한 라이브러리(Symfony ExpressionLanguage 같은) 사용.

예: 수학식 계산을 허용해야 하면 **안전한 수학 파서** 사용(숫자·연산자만 허용).

## 3) `create_function()` 대체

`create_function()`은 익명 함수 문법(`function(...) { ... }`)이나 `Closure`로 대체하라.
또한 동적 문자열로 코드를 만들지 마라.

```php
// 위험: create_function 사용 금지
// $f = create_function('$a', 'return '.$_GET['expr'].';');

// 안전: 미리 정의된 동작 사용
$f = function($a) { return safe_operation($a); };
```


