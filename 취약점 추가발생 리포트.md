\*\*`<a href="&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;alert(1)">Click me</a>`\*\*에서 \*\*"Click me"\*\*라는 텍스트를 클릭했을 때 **알림창**이 뜨는 원리는 다음과 같습니다.

### 1. **HTML 코드 분석**

이 코드는 \*\*HTML 앵커 태그 (`<a>`)\*\*를 사용하여 링크를 만들고 있습니다. 그런데 **`href` 속성**에 **`javascript:`** 프로토콜이 포함되어 있습니다. 이때 중요한 점은 **`href` 속성에 자바스크립트 코드**가 들어있다는 것입니다.

* **`href="&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;alert(1)"`** 부분은 **HTML 엔티티**로 인코딩된 **`javascript:`** 프로토콜입니다.
* `&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;`는 **ASCII 코드로 인코딩된 `javascript:`** 입니다.

  * 디코딩하면 \*\*`javascript:`\*\*가 됩니다.

즉, 이 코드는 `href="javascript:alert(1)"`와 동일한 역할을 합니다.

### 2. **`<a>` 태그의 기본 동작**

**`<a>` 태그**는 **링크**를 만드는 역할을 합니다. 보통 **`href` 속성**에 URL을 넣어서 링크를 정의하지만, 이 경우 **`javascript:`** 프로토콜을 사용하여 **자바스크립트 코드를 실행**하는 링크로 만들어집니다.

* \*\*`href="javascript:alert(1)"`\*\*는 **자바스크립트 코드를 실행**하는 링크입니다.
* 이 링크를 클릭하면 \*\*`alert(1)`\*\*이 실행되므로 **알림창**이 뜨게 됩니다.

### 3. **자바스크립트 `javascript:` 프로토콜**

* \*\*`javascript:`\*\*는 특별한 **프로토콜**입니다. 일반적으로 **URL**을 통해 다른 페이지로 이동하거나 자원을 로드하지만, **`javascript:`** 프로토콜을 사용하면 **자바스크립트 코드**를 실행할 수 있습니다.
* \*\*`javascript:`\*\*로 시작하는 링크는 **자바스크립트 코드**가 바로 실행되도록 합니다. 이 코드에서는 \*\*`alert(1)`\*\*을 실행하여 알림창을 띄웁니다.

### 4. **HTML 엔티티와 자바스크립트 실행**

* `&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;`는 \*\*`javascript:`\*\*를 **HTML 엔티티**로 인코딩한 것입니다. 이는 보안 필터나 XSS 방어를 우회하기 위한 기법일 수 있습니다.
* 브라우저에서 이 **HTML 엔티티**를 **디코딩**하여 **`javascript:`** 프로토콜로 해석하고, 해당 자바스크립트 코드가 실행됩니다.

### 5. **"Click me" 텍스트**

* \*\*`<a href="javascript:alert(1)">Click me</a>`\*\*에서 \*\*"Click me"\*\*는 단순히 링크의 **텍스트**입니다.
* 사용자가 \*\*"Click me"\*\*라는 텍스트를 클릭하면 **`href="javascript:alert(1)"`** 속성에 정의된 자바스크립트 코드가 실행되며, **알림창**이 뜨게 됩니다.

### 6. **클릭 시 발생하는 일**

* 사용자가 **"Click me"** 텍스트를 클릭하면, \*\*`href="javascript:alert(1)"`\*\*가 실행됩니다.
* **자바스크립트 `alert(1)`** 코드가 실행되어 **알림창**이 뜨는 것입니다.

---

### **핵심 원리**

1. **`<a>` 태그**는 기본적으로 **링크**를 클릭할 때 **다른 페이지로 이동**하는 역할을 합니다.
2. 하지만 **`href` 속성**에 **`javascript:`** 프로토콜을 사용하면 **자바스크립트 코드를 실행**하는 링크가 됩니다.
3. **`javascript:alert(1)`** 코드는 **알림창을 띄우는 자바스크립트 코드**입니다.
4. **HTML 엔티티**로 **`javascript:`** 프로토콜을 인코딩한 것은 보안 필터링을 우회하기 위한 방법입니다.
5. 사용자가 \*\*"Click me"\*\*를 클릭하면, **자바스크립트 코드**가 실행되어 **알림창**이 표시됩니다.

### 결론

\*\*"Click me"\*\*를 클릭하는 순간, **`<a>` 태그의 `href` 속성**에 정의된 **`javascript:alert(1)`** 코드가 실행되어, **알림창**이 뜨게 되는 원리입니다.



이 문제는 **HTML 엔티티 인코딩(HTML Entity Encoding)** 또는 **입력값 필터링** 문제로 보입니다. 주어진 코드에서 `<a href="javascript:alert('23')">Click me</a>`와 같은 태그가 그대로 HTML에 반영되는 대신, HTML 특수 문자가 엔티티 형식으로 변환되어 `<input>` 요소의 `value` 속성에 삽입된 것으로 보입니다.

### 문제 분석

1. **엔티티 변환 문제**:

   * HTML에서 `<`, `>`, `"` 같은 특수 문자는 직접 사용될 경우 HTML 구문에서 문제가 생길 수 있습니다. 그래서 `<a href="javascript:alert('23')">Click me</a>`와 같은 구문은 자동으로 `&lt;a href="javascript:alert('23')">Click me&lt;/a>`와 같이 변환됩니다. 이것은 HTML이 태그로 해석되지 않고 텍스트로 그대로 표시되도록 하는 안전장치입니다.
2. **HTML 특수 문자 처리**:

   * `value="&lt;a href=" void:alert('23')">"Click me">"`처럼 특수 문자들이 엔티티로 변환된 이유는 **입력값을 필터링/변환하는 처리**가 있을 때 발생할 수 있습니다. 이 경우 입력값을 **자동으로 필터링하여 특수 문자를 엔티티로 인코딩**하여 반영하게 됩니다.
3. **`javascript:` 프로토콜 차단**:

   * 이 문제에서는 `href="javascript:alert('23')"`가 제대로 작동하지 않는데, `javascript:` 프로토콜이 CSP(Content Security Policy)나 필터링에서 차단되었을 가능성이 높습니다.

### 문제의 취약점 분석

현재 `<input>`에 삽입된 값은 단순히 텍스트로 보입니다. 하지만, 여기서 발생할 수 있는 취약점은 **DOM-Based XSS**와 관련이 있을 수 있습니다. 예를 들어, **값을 동적으로 HTML로 삽입하는 과정에서 이벤트 핸들러가 실행될 수 있는 상황**이 발생할 수 있습니다.

### 취약점 진단 방법

1. **`value` 속성에 삽입된 사용자 입력값 확인**:

   * `value` 속성에 삽입된 값이 필터링되지 않거나 **DOM 조작을 통해 삽입된 데이터**가 제대로 처리되지 않으면, 클라이언트 사이드에서 **XSS가 발생할 수 있습니다**. 예를 들어, `document.getElementById('SearchWord').value`를 사용하여 이 값을 DOM에 반영하는 코드가 있을 수 있습니다.

2. **입력값이 HTML로 삽입되는지 테스트**:

   * 만약 `input` 값이 페이지에 표시될 때 자바스크립트 코드가 실행된다면, **DOM 기반 XSS**가 발생할 수 있습니다. 자바스크립트나 이벤트 핸들러가 **동적으로 삽입되는 방식**으로 처리되면 악성 코드가 실행될 수 있습니다.

3. **`<input>` 요소의 값을 사용하여 동적 HTML 생성**:

   * `value` 속성의 입력값을 **`innerHTML`** 또는 **`document.write()`** 등의 메서드를 사용하여 HTML로 삽입하는 경우 XSS가 발생할 수 있습니다. 예를 들어:

     ```javascript
     let inputValue = document.getElementById('SearchWord').value;
     document.getElementById('output').innerHTML = inputValue;
     ```

     위 코드처럼 `input` 값을 직접 `innerHTML`로 삽입하면, 악성 JavaScript 코드도 실행될 수 있습니다.

4. **XSS 필터 우회 방법 테스트**:

   * 여러 가지 테스트 방법을 시도할 수 있습니다. 예를 들어, `&lt;a href="javascript:alert(1)">Click me&lt;/a>`가 여전히 HTML 코드로 실행되지 않는다면, 다른 우회 방법을 사용하여 **XSS를 트리거**할 수 있는지 확인할 수 있습니다.

---

### 취약점 우회 방법 및 테스트

1. **HTML 엔티티 인코딩 우회**:

   * 만약 `javascript:` 프로토콜이 차단된 경우, **HTML 엔티티**로 우회할 수 있습니다. 예를 들어:

     ```html
     <a href="&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;alert(1)">Click me</a>
     ```

     이처럼 `javascript:`를 HTML 문자 코드로 바꾸어 우회할 수 있습니다.

2. **DOM Based XSS**:

   * 만약 입력값이 **DOM을 통해 삽입**될 때 필터링이 제대로 되지 않으면, XSS를 발생시킬 수 있습니다. 예를 들어:

     ```javascript
     let inputValue = document.getElementById('SearchWord').value;
     document.getElementById('output').innerHTML = inputValue;
     ```

     위 코드에서는 `<input>`의 `value` 속성값이 **HTML로 삽입**되기 때문에 **XSS**가 발생할 수 있습니다.

3. **자바스크립트와 HTML의 결합**:

   * `input` 요소의 `value`에 `javascript:` 프로토콜을 포함시키는 것 외에도, 다른 방식으로 **자바스크립트 코드를 실행**할 수 있는 우회 방법을 찾을 수 있습니다. 예를 들어:

     ```html
     <input type="text" id="SearchWord" value="<script>alert('XSS')</script>">
     ```

     또는 **자바스크립트 코드**를 **URL 인코딩**하여 입력할 수도 있습니다.

4. **이벤트 핸들러 조작**:

   * **`onfocus`**, **`onblur`** 등과 같은 HTML 이벤트 핸들러를 사용하여 입력값을 실행할 수 있습니다. 예를 들어:

     ```html
     <input type="text" id="SearchWord" value="<input onfocus=alert(1)>">
     ```

---

### 결론

현재 상황에서는 HTML 엔티티로 변환된 코드가 그대로 텍스트로 표시되고 있는 것으로 보입니다. 이를 통해 **DOM 기반 XSS**가 발생할 수 있는 상황임을 알 수 있습니다. 추가적으로 `value` 속성에 악성 코드가 삽입될 수 있는지 테스트하고, **클라이언트 측에서 HTML을 동적으로 생성하는 방식**이 있을 경우 이를 조심해야 합니다.
