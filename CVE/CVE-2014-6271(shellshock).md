## * **Shellshock 취약점(CVE-2014-6271 계열)**

```
() { ignored; }; echo Content-Type: text/html; echo ; /bin/cat /etc/passwd,; }; echo Content-Type: text/html; echo ; /bin/cat /etc/passwd, /bin/cat,/bin/cat /etc/passwd
```

### 무슨 공격인가?


*  **환경변수에 Bash 함수 정의를 주입한 뒤**( `() { ...; };` ) 해당 환경이 CGI 등으로 취약하게 호출될 때 Bash가 함수 본문 뒤의 `;` 이후 내용을 **명령으로 실행**하도록 유도해 시스템 명령(`/bin/cat /etc/passwd`)을 실행하려는 전형적 Shellshock 시도.

  * `() { :; }; <command>` 형태는 환경변수에 함수 정의을 넣고 이후에 커맨드를 실행시켜, CGI 환경(예: Apache + mod_cgi/mod_cgid)에서 `bash`가 취약한 경우 원격 명령 실행이 가능하게 합니다.
* 여기서는 `/bin/cat /etc/passwd`를 실행해 파일 내용을 노출시키려 함(취약성 존재 여부 확인용).


1. `() { ignored; };`

   * 형태: `() { <body> ; };`
   * 의미: Bash에서 함수 정의 구문입니다. 예: `f() { echo hi; };` 는 함수 `f`를 정의.
   * Shellshock 트릭: 취약한 Bash는 **환경변수 값**이 위와 같은 함수 정의로 시작하면(예: 환경변수 `V="() { :; }; <payload>"`) 함수 정의 이후의 `;` 뒤에 붙은 텍스트를 함수 정의의 일부가 아닌 **추가 명령**으로 해석/실행하는 버그가 있었습니다.
   * 여기서 `ignored;` 는 함수 본문(무해한 더미)으로, 실제 악성 명령은 함수 정의 닫은 뒤(`};`)에 바로 이어지게 됩니다.

2. `echo Content-Type: text/html; echo ;`

   * 맥락: CGI 스크립트가 출력하는 HTTP 응답 헤더 형식(예: `Content-Type: text/html`)을 흉내내려는 구문입니다.
   * 이유: 공격자가 웹 브라우저(또는 스캐너)로 결과를 읽어보려면 **HTTP 응답 헤더**와 본문을 올바르게 구성해야 합니다. CGI 환경에서 실행된 쉘 출력이 응답으로 전달될 때 헤더/본문 구분을 만들어주기 위한 시도입니다.
   * (즉, 공격자는 출력이 브라우저에 제대로 보이도록 헤더 라인을 출력하게 하는 겁니다.)

3. `/bin/cat /etc/passwd,;`  그리고 `/bin/cat /etc/passwd` 반복

   * 핵심 명령: `/bin/cat /etc/passwd` — 전통적으로 시스템의 사용자 계정 정보를 담은 파일을 읽어 노출하는 명령입니다(정보수집 목적).
   * 쉼표(,)와 `;` 혼합: 원문에는 쉼표와 세미콜론이 중복·혼입되어 있는데, 이는 **스크립트가 자동생성되거나 스캐너가 다양한 변형을 동시에 전송**한 흔적일 가능성이 큽니다. 쉼표 자체는 쉘 문법에서 명령 구분자가 아니므로 일부 변형은 무시되거나 문법 오류를 초래하지만, 취약 검사 목적이라면 단순 반복·잡음이 섞인 경우가 많습니다.
   * 반복 이유: 탐색기(스캐너)가 다양한 문법 변형을 시도해서 그중 하나라도 성공하면 결과를 확인하려는 목적일 수 있습니다.

4. 중복된 `}; echo Content-Type...` 블록들

   * 의미상 중복/잘림: 여러 번 반복되거나 괄호가 닫힌 뒤 또 닫으려는(또는 잘린) 흔적이 있음.
   * 이유: 자동화 스캐너/봇들이 변형을 붙여 보낼 때 페이로드가 중복되거나 전송 과정에서 잘려서 로그에 남는 경우가 흔함. 완벽한 페이로드가 아닌데도 공격 시도 자체는 의미가 있습니다.

---

### 왜 이게 CGI 환경에서 동작하나(취약 메커니즘 요약)

* 일반적으로 웹서버(CGI) → 요청을 처리할 때 요청 헤더를 환경변수로 CGI 스크립트(예: `/usr/bin/env bash`가 호출되는 경우)에 전달합니다.
* 문제의 Bash 버전(취약한 버전)은 **환경변수 값 맨 앞이 함수 정의 형태**로 시작하면 그 뒤에 오는 텍스트를 함수 정의 이후의 명령으로 잘못 실행했습니다.
* 결과: 공격자가 HTTP 헤더(예: `User-Agent` 또는 `Referer`)에 `() { :; }; <payload>`를 넣어 전송하면, 서버가 이 헤더를 환경변수로 넘기고, 취약한 Bash가 이를 해석하면서 `<payload>`를 실행합니다.
